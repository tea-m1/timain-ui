/* tslint:disable */
/* eslint-disable */
/**
 * TEAM MAIN
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {Configuration} from "./configuration";
import type {AxiosPromise, AxiosInstance, RawAxiosRequestConfig} from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type {RequestArgs} from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Activation
 */
export interface Activation {
  /**
   *
   * @type {string}
   * @memberof Activation
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof Activation
   */
  token: string;
}
/**
 *
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  address: string;
  /**
   *
   * @type {Date}
   * @memberof CreateUser
   */
  registrationDate?: Date;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  gender: CreateUserGenderEnum;
}

export const CreateUserGenderEnum = {
  MALE: "MALE",
  FEMALE: "FEMALE",
} as const;

export type CreateUserGenderEnum =
  (typeof CreateUserGenderEnum)[keyof typeof CreateUserGenderEnum];

/**
 *
 * @export
 * @interface GetUserProfile
 */
export interface GetUserProfile {
  /**
   * Username of the user associated with this user profile
   * @type {string}
   * @memberof GetUserProfile
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  address: string;
  /**
   *
   * @type {Date}
   * @memberof GetUserProfile
   */
  registrationDate?: Date;
  /**
   *
   * @type {string}
   * @memberof GetUserProfile
   */
  gender: GetUserProfileGenderEnum;
}

export const GetUserProfileGenderEnum = {
  MALE: "MALE",
  FEMALE: "FEMALE",
} as const;

export type GetUserProfileGenderEnum =
  (typeof GetUserProfileGenderEnum)[keyof typeof GetUserProfileGenderEnum];

/**
 *
 * @export
 * @interface Location
 */
export interface Location {
  /**
   *
   * @type {number}
   * @memberof Location
   */
  latitude: number;
  /**
   *
   * @type {number}
   * @memberof Location
   */
  longitude: number;
}
/**
 *
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
  /**
   *
   * @type {string}
   * @memberof ModelFile
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ModelFile
   */
  reference?: string;
  /**
   *
   * @type {string}
   * @memberof ModelFile
   */
  createdAt?: string;
}
/**
 *
 * @export
 * @interface Order
 */
export interface Order {
  /**
   *
   * @type {string}
   * @memberof Order
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  productId?: string;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  quantity?: number;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  totalAmount?: number;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  status?: OrderStatusEnum;
}

export const OrderStatusEnum = {
  PENDING: "PENDING",
  COMPLETED: "COMPLETED",
  CANCELLED: "CANCELLED",
} as const;

export type OrderStatusEnum =
  (typeof OrderStatusEnum)[keyof typeof OrderStatusEnum];

/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   *
   * @type {string}
   * @memberof Place
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Place
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Place
   */
  description?: string;
  /**
   *
   * @type {Location}
   * @memberof Place
   */
  location?: Location;
}
/**
 *
 * @export
 * @interface PlacesGet200Response
 */
export interface PlacesGet200Response {
  /**
   *
   * @type {Array<Place>}
   * @memberof PlacesGet200Response
   */
  data?: Array<Place>;
  /**
   *
   * @type {number}
   * @memberof PlacesGet200Response
   */
  total?: number;
  /**
   *
   * @type {number}
   * @memberof PlacesGet200Response
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof PlacesGet200Response
   */
  pageSize?: number;
}
/**
 *
 * @export
 * @interface Product
 */
export interface Product {
  /**
   *
   * @type {string}
   * @memberof Product
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  price?: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  image?: string;
}
/**
 *
 * @export
 * @interface ProductsGet200Response
 */
export interface ProductsGet200Response {
  /**
   *
   * @type {Array<Product>}
   * @memberof ProductsGet200Response
   */
  data?: Array<Product>;
  /**
   *
   * @type {number}
   * @memberof ProductsGet200Response
   */
  total?: number;
  /**
   *
   * @type {number}
   * @memberof ProductsGet200Response
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof ProductsGet200Response
   */
  pageSize?: number;
}
/**
 *
 * @export
 * @interface SetPassword
 */
export interface SetPassword {
  /**
   *
   * @type {string}
   * @memberof SetPassword
   */
  new_password: string;
  /**
   *
   * @type {string}
   * @memberof SetPassword
   */
  current_password: string;
}
/**
 *
 * @export
 * @interface SetUsername
 */
export interface SetUsername {
  /**
   *
   * @type {string}
   * @memberof SetUsername
   */
  current_password: string;
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @type {string}
   * @memberof SetUsername
   */
  new_username: string;
}
/**
 *
 * @export
 * @interface Species
 */
export interface Species {
  /**
   *
   * @type {string}
   * @memberof Species
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Species
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Species
   */
  scientificName?: string;
  /**
   * The specific type of species (e.g., Mammal, Bird, Tree, Flower)
   * @type {string}
   * @memberof Species
   */
  type: SpeciesTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Species
   */
  description: string;
  /**
   *
   * @type {Array<any>}
   * @memberof Species
   */
  image?: Array<any>;
  /**
   * The type of entity (e.g., Animal or Plant)
   * @type {string}
   * @memberof Species
   */
  entityType: SpeciesEntityTypeEnum;
}

export const SpeciesTypeEnum = {
  Mammal: "Mammal",
  Bird: "Bird",
  Reptile: "Reptile",
  Amphibian: "Amphibian",
  Fish: "Fish",
  Insect: "Insect",
  Tree: "Tree",
  Flower: "Flower",
  Shrub: "Shrub",
  Grass: "Grass",
} as const;

export type SpeciesTypeEnum =
  (typeof SpeciesTypeEnum)[keyof typeof SpeciesTypeEnum];
export const SpeciesEntityTypeEnum = {
  Animal: "Animal",
  Plant: "Plant",
} as const;

export type SpeciesEntityTypeEnum =
  (typeof SpeciesEntityTypeEnum)[keyof typeof SpeciesEntityTypeEnum];

/**
 *
 * @export
 * @interface SpeciesGet200Response
 */
export interface SpeciesGet200Response {
  /**
   *
   * @type {Array<Species>}
   * @memberof SpeciesGet200Response
   */
  data?: Array<Species>;
  /**
   *
   * @type {number}
   * @memberof SpeciesGet200Response
   */
  total?: number;
  /**
   *
   * @type {number}
   * @memberof SpeciesGet200Response
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof SpeciesGet200Response
   */
  pageSize?: number;
}
/**
 *
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
  /**
   * Access token
   * @type {string}
   * @memberof TokenPair
   */
  access?: string;
  /**
   * Refresh token
   * @type {string}
   * @memberof TokenPair
   */
  refresh?: string;
}
/**
 *
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
  /**
   *
   * @type {string}
   * @memberof TokenRefresh
   */
  access?: string;
  /**
   *
   * @type {string}
   * @memberof TokenRefresh
   */
  refresh?: string;
}
/**
 *
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
  /**
   *
   * @type {string}
   * @memberof TokenVerify
   */
  token: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  address: string;
  /**
   *
   * @type {Date}
   * @memberof User
   */
  registrationDate?: Date;
  /**
   *
   * @type {string}
   * @memberof User
   */
  gender: UserGenderEnum;
}

export const UserGenderEnum = {
  MALE: "MALE",
  FEMALE: "FEMALE",
} as const;

export type UserGenderEnum =
  (typeof UserGenderEnum)[keyof typeof UserGenderEnum];

/**
 *
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
  /**
   *
   * @type {string}
   * @memberof UserLogin
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserLogin
   */
  password: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const UserRole = {
  ADMIN: "ADMIN",
  USER: "USER",
} as const;

export type UserRole = (typeof UserRole)[keyof typeof UserRole];

/**
 *
 * @export
 * @interface VerifyToken401Response
 */
export interface VerifyToken401Response {
  /**
   *
   * @type {string}
   * @memberof VerifyToken401Response
   */
  detail?: string;
  /**
   *
   * @type {string}
   * @memberof VerifyToken401Response
   */
  code?: string;
}
/**
 *
 * @export
 * @interface Whoami
 */
export interface Whoami {
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  userId?: string;
  /**
   *
   * @type {number}
   * @memberof Whoami
   */
  exp?: number;
  /**
   * Username of the user associated with this user profile
   * @type {string}
   * @memberof Whoami
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  address: string;
  /**
   *
   * @type {Date}
   * @memberof Whoami
   */
  registrationDate?: Date;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  gender: WhoamiGenderEnum;
}

export const WhoamiGenderEnum = {
  MALE: "MALE",
  FEMALE: "FEMALE",
} as const;

export type WhoamiGenderEnum =
  (typeof WhoamiGenderEnum)[keyof typeof WhoamiGenderEnum];

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Change the password
     * @param {SetPassword} setPassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      setPassword: SetPassword,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'setPassword' is not null or undefined
      assertParamExists("changePassword", "setPassword", setPassword);
      const localVarPath = `/users/set_password/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setPassword,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetUsername} setUsername
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeUsername: async (
      setUsername: SetUsername,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'setUsername' is not null or undefined
      assertParamExists("changeUsername", "setUsername", setUsername);
      const localVarPath = `/users/set_username/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUsername,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Only admin users are allowed to get all users
     * @param {string} [username] User that the username contains the lookup value
     * @param {UserRole} [role] Search for the user that has the specified role
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      username?: string,
      role?: UserRole,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (role !== undefined) {
        localVarQueryParameter["role"] = role;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register
     * @param {CreateUser} createUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (
      createUser: CreateUser,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUser' is not null or undefined
      assertParamExists("signup", "createUser", createUser);
      const localVarPath = `/users/signup/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Change the password
     * @param {SetPassword} setPassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      setPassword: SetPassword,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(
        setPassword,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountApi.changePassword"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {SetUsername} setUsername
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeUsername(
      setUsername: SetUsername,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetUsername>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changeUsername(
        setUsername,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountApi.changeUsername"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Only admin users are allowed to get all users
     * @param {string} [username] User that the username contains the lookup value
     * @param {UserRole} [role] Search for the user that has the specified role
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      username?: string,
      role?: UserRole,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CreateUser>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        username,
        role,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountApi.getUsers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Register
     * @param {CreateUser} createUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      createUser: CreateUser,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(
        createUser,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountApi.signup"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AccountApiFp(configuration);
  return {
    /**
     *
     * @summary Change the password
     * @param {SetPassword} setPassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      setPassword: SetPassword,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .changePassword(setPassword, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SetUsername} setUsername
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeUsername(
      setUsername: SetUsername,
      options?: any
    ): AxiosPromise<SetUsername> {
      return localVarFp
        .changeUsername(setUsername, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Only admin users are allowed to get all users
     * @param {string} [username] User that the username contains the lookup value
     * @param {UserRole} [role] Search for the user that has the specified role
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      username?: string,
      role?: UserRole,
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<Array<CreateUser>> {
      return localVarFp
        .getUsers(username, role, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Register
     * @param {CreateUser} createUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(createUser: CreateUser, options?: any): AxiosPromise<Whoami> {
      return localVarFp
        .signup(createUser, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
  /**
   *
   * @summary Change the password
   * @param {SetPassword} setPassword
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public changePassword(
    setPassword: SetPassword,
    options?: RawAxiosRequestConfig
  ) {
    return AccountApiFp(this.configuration)
      .changePassword(setPassword, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SetUsername} setUsername
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public changeUsername(
    setUsername: SetUsername,
    options?: RawAxiosRequestConfig
  ) {
    return AccountApiFp(this.configuration)
      .changeUsername(setUsername, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Only admin users are allowed to get all users
   * @param {string} [username] User that the username contains the lookup value
   * @param {UserRole} [role] Search for the user that has the specified role
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getUsers(
    username?: string,
    role?: UserRole,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return AccountApiFp(this.configuration)
      .getUsers(username, role, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Register
   * @param {CreateUser} createUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public signup(createUser: CreateUser, options?: RawAxiosRequestConfig) {
    return AccountApiFp(this.configuration)
      .signup(createUser, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @summary Login connexion
     * @param {UserLogin} userLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      userLogin: UserLogin,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userLogin' is not null or undefined
      assertParamExists("login", "userLogin", userLogin);
      const localVarPath = `/auth/login/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLogin,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (
      tokenRefresh: TokenRefresh,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenRefresh' is not null or undefined
      assertParamExists("refreshToken", "tokenRefresh", tokenRefresh);
      const localVarPath = `/auth/refresh/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tokenRefresh,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Takes a token and indicates if it is valid. This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} tokenVerify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyToken: async (
      tokenVerify: TokenVerify,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenVerify' is not null or undefined
      assertParamExists("verifyToken", "tokenVerify", tokenVerify);
      const localVarPath = `/auth/verify/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tokenVerify,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Whois the account related by the provided token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/whoami/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @summary Login connexion
     * @param {UserLogin} userLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      userLogin: UserLogin,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        userLogin,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthenticationApi.login"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      tokenRefresh: TokenRefresh,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(
        tokenRefresh,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthenticationApi.refreshToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Takes a token and indicates if it is valid. This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} tokenVerify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyToken(
      tokenVerify: TokenVerify,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenVerify>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyToken(
        tokenVerify,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthenticationApi.verifyToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Whois the account related by the provided token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthenticationApi.whoami"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @summary Login connexion
     * @param {UserLogin} userLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(userLogin: UserLogin, options?: any): AxiosPromise<TokenPair> {
      return localVarFp
        .login(userLogin, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(
      tokenRefresh: TokenRefresh,
      options?: any
    ): AxiosPromise<TokenRefresh> {
      return localVarFp
        .refreshToken(tokenRefresh, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Takes a token and indicates if it is valid. This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} tokenVerify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyToken(
      tokenVerify: TokenVerify,
      options?: any
    ): AxiosPromise<TokenVerify> {
      return localVarFp
        .verifyToken(tokenVerify, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Whois the account related by the provided token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<Whoami> {
      return localVarFp
        .whoami(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
   * @summary Login connexion
   * @param {UserLogin} userLogin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public login(userLogin: UserLogin, options?: RawAxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .login(userLogin, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
   * @param {TokenRefresh} tokenRefresh
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public refreshToken(
    tokenRefresh: TokenRefresh,
    options?: RawAxiosRequestConfig
  ) {
    return AuthenticationApiFp(this.configuration)
      .refreshToken(tokenRefresh, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Takes a token and indicates if it is valid. This view provides no information about a token\'s fitness for a particular use.
   * @param {TokenVerify} tokenVerify
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public verifyToken(
    tokenVerify: TokenVerify,
    options?: RawAxiosRequestConfig
  ) {
    return AuthenticationApiFp(this.configuration)
      .verifyToken(tokenVerify, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Whois the account related by the provided token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public whoami(options?: RawAxiosRequestConfig) {
    return AuthenticationApiFp(this.configuration)
      .whoami(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BiodiversityApi - axios parameter creator
 * @export
 */
export const BiodiversityApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary List all places
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesGet: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/places`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a place
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("placesIdDelete", "id", id);
      const localVarPath = `/places/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get place by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("placesIdGet", "id", id);
      const localVarPath = `/places/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a place
     * @param {string} id
     * @param {Place} place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesIdPut: async (
      id: string,
      place: Place,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("placesIdPut", "id", id);
      // verify required parameter 'place' is not null or undefined
      assertParamExists("placesIdPut", "place", place);
      const localVarPath = `/places/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        place,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a new place
     * @param {Place} place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesPost: async (
      place: Place,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'place' is not null or undefined
      assertParamExists("placesPost", "place", place);
      const localVarPath = `/places`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        place,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all species
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesGet: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/species`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a species
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("speciesIdDelete", "id", id);
      const localVarPath = `/species/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get species by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("speciesIdGet", "id", id);
      const localVarPath = `/species/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a species
     * @param {string} id
     * @param {Species} species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesIdPut: async (
      id: string,
      species: Species,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("speciesIdPut", "id", id);
      // verify required parameter 'species' is not null or undefined
      assertParamExists("speciesIdPut", "species", species);
      const localVarPath = `/species/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        species,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a new species
     * @param {Species} species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesPost: async (
      species: Species,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'species' is not null or undefined
      assertParamExists("speciesPost", "species", species);
      const localVarPath = `/species`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        species,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BiodiversityApi - functional programming interface
 * @export
 */
export const BiodiversityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BiodiversityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary List all places
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async placesGet(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlacesGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.placesGet(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.placesGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a place
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async placesIdDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.placesIdDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get place by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async placesIdGet(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Place>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdGet(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.placesIdGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a place
     * @param {string} id
     * @param {Place} place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async placesIdPut(
      id: string,
      place: Place,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Place>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.placesIdPut(
        id,
        place,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.placesIdPut"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add a new place
     * @param {Place} place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async placesPost(
      place: Place,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Place>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.placesPost(
        place,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.placesPost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List all species
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speciesGet(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SpeciesGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speciesGet(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.speciesGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a species
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speciesIdDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speciesIdDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.speciesIdDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get species by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speciesIdGet(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Species>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speciesIdGet(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.speciesIdGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a species
     * @param {string} id
     * @param {Species} species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speciesIdPut(
      id: string,
      species: Species,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Species>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speciesIdPut(
        id,
        species,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.speciesIdPut"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add a new species
     * @param {Species} species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async speciesPost(
      species: Species,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Species>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.speciesPost(
        species,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BiodiversityApi.speciesPost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BiodiversityApi - factory interface
 * @export
 */
export const BiodiversityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BiodiversityApiFp(configuration);
  return {
    /**
     *
     * @summary List all places
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesGet(
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<PlacesGet200Response> {
      return localVarFp
        .placesGet(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a place
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesIdDelete(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .placesIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get place by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesIdGet(id: string, options?: any): AxiosPromise<Place> {
      return localVarFp
        .placesIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a place
     * @param {string} id
     * @param {Place} place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesIdPut(id: string, place: Place, options?: any): AxiosPromise<Place> {
      return localVarFp
        .placesIdPut(id, place, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a new place
     * @param {Place} place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    placesPost(place: Place, options?: any): AxiosPromise<Place> {
      return localVarFp
        .placesPost(place, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all species
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesGet(
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SpeciesGet200Response> {
      return localVarFp
        .speciesGet(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a species
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesIdDelete(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .speciesIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get species by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesIdGet(id: string, options?: any): AxiosPromise<Species> {
      return localVarFp
        .speciesIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a species
     * @param {string} id
     * @param {Species} species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesIdPut(
      id: string,
      species: Species,
      options?: any
    ): AxiosPromise<Species> {
      return localVarFp
        .speciesIdPut(id, species, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a new species
     * @param {Species} species
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    speciesPost(species: Species, options?: any): AxiosPromise<Species> {
      return localVarFp
        .speciesPost(species, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BiodiversityApi - object-oriented interface
 * @export
 * @class BiodiversityApi
 * @extends {BaseAPI}
 */
export class BiodiversityApi extends BaseAPI {
  /**
   *
   * @summary List all places
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public placesGet(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return BiodiversityApiFp(this.configuration)
      .placesGet(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a place
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public placesIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return BiodiversityApiFp(this.configuration)
      .placesIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get place by ID
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public placesIdGet(id: string, options?: RawAxiosRequestConfig) {
    return BiodiversityApiFp(this.configuration)
      .placesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a place
   * @param {string} id
   * @param {Place} place
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public placesIdPut(
    id: string,
    place: Place,
    options?: RawAxiosRequestConfig
  ) {
    return BiodiversityApiFp(this.configuration)
      .placesIdPut(id, place, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a new place
   * @param {Place} place
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public placesPost(place: Place, options?: RawAxiosRequestConfig) {
    return BiodiversityApiFp(this.configuration)
      .placesPost(place, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all species
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public speciesGet(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return BiodiversityApiFp(this.configuration)
      .speciesGet(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a species
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public speciesIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return BiodiversityApiFp(this.configuration)
      .speciesIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get species by ID
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public speciesIdGet(id: string, options?: RawAxiosRequestConfig) {
    return BiodiversityApiFp(this.configuration)
      .speciesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a species
   * @param {string} id
   * @param {Species} species
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public speciesIdPut(
    id: string,
    species: Species,
    options?: RawAxiosRequestConfig
  ) {
    return BiodiversityApiFp(this.configuration)
      .speciesIdPut(id, species, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a new species
   * @param {Species} species
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BiodiversityApi
   */
  public speciesPost(species: Species, options?: RawAxiosRequestConfig) {
    return BiodiversityApiFp(this.configuration)
      .speciesPost(species, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ECommerceApi - axios parameter creator
 * @export
 */
export const ECommerceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create a new order
     * @param {Order} order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersPost: async (
      order: Order,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'order' is not null or undefined
      assertParamExists("ordersPost", "order", order);
      const localVarPath = `/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        order,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all products
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsGet: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a product
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productsIdDelete", "id", id);
      const localVarPath = `/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get product by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productsIdGet", "id", id);
      const localVarPath = `/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a product
     * @param {string} id
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsIdPut: async (
      id: string,
      product: Product,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("productsIdPut", "id", id);
      // verify required parameter 'product' is not null or undefined
      assertParamExists("productsIdPut", "product", product);
      const localVarPath = `/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        product,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a new product
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsPost: async (
      product: Product,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'product' is not null or undefined
      assertParamExists("productsPost", "product", product);
      const localVarPath = `/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        product,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ECommerceApi - functional programming interface
 * @export
 */
export const ECommerceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ECommerceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a new order
     * @param {Order} order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ordersPost(
      order: Order,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPost(
        order,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ECommerceApi.ordersPost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List all products
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productsGet(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProductsGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ECommerceApi.productsGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a product
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productsIdDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.productsIdDelete(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ECommerceApi.productsIdDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get product by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productsIdGet(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.productsIdGet(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ECommerceApi.productsIdGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a product
     * @param {string} id
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productsIdPut(
      id: string,
      product: Product,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.productsIdPut(
        id,
        product,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ECommerceApi.productsIdPut"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add a new product
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async productsPost(
      product: Product,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.productsPost(
        product,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ECommerceApi.productsPost"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ECommerceApi - factory interface
 * @export
 */
export const ECommerceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ECommerceApiFp(configuration);
  return {
    /**
     *
     * @summary Create a new order
     * @param {Order} order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersPost(order: Order, options?: any): AxiosPromise<Order> {
      return localVarFp
        .ordersPost(order, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all products
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsGet(
      page?: number,
      pageSize?: number,
      options?: any
    ): AxiosPromise<ProductsGet200Response> {
      return localVarFp
        .productsGet(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a product
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsIdDelete(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .productsIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get product by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsIdGet(id: string, options?: any): AxiosPromise<Product> {
      return localVarFp
        .productsIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a product
     * @param {string} id
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsIdPut(
      id: string,
      product: Product,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .productsIdPut(id, product, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a new product
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsPost(product: Product, options?: any): AxiosPromise<Product> {
      return localVarFp
        .productsPost(product, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ECommerceApi - object-oriented interface
 * @export
 * @class ECommerceApi
 * @extends {BaseAPI}
 */
export class ECommerceApi extends BaseAPI {
  /**
   *
   * @summary Create a new order
   * @param {Order} order
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ECommerceApi
   */
  public ordersPost(order: Order, options?: RawAxiosRequestConfig) {
    return ECommerceApiFp(this.configuration)
      .ordersPost(order, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all products
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ECommerceApi
   */
  public productsGet(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ECommerceApiFp(this.configuration)
      .productsGet(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a product
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ECommerceApi
   */
  public productsIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return ECommerceApiFp(this.configuration)
      .productsIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get product by ID
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ECommerceApi
   */
  public productsIdGet(id: string, options?: RawAxiosRequestConfig) {
    return ECommerceApiFp(this.configuration)
      .productsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a product
   * @param {string} id
   * @param {Product} product
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ECommerceApi
   */
  public productsIdPut(
    id: string,
    product: Product,
    options?: RawAxiosRequestConfig
  ) {
    return ECommerceApiFp(this.configuration)
      .productsIdPut(id, product, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a new product
   * @param {Product} product
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ECommerceApi
   */
  public productsPost(product: Product, options?: RawAxiosRequestConfig) {
    return ECommerceApiFp(this.configuration)
      .productsPost(product, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.ping"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp
        .ping(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
